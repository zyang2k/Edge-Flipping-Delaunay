from incirclefast import *
from triangulation import *
from findCircle import *
from sympy import *
from sympy.geometry import *
import random
import matplotlib.pyplot as plt
import time

def generalPosition(numOfPoints):
  """
  This function generates random points in general positions.
  """
  #Initiate an empty list
  points_in_general = []
  
  # initiate w/ two points
  for h in range(2):
    points_in_general.append(Point(random.randint(-10, 10), random.randint(-10, 10)))
    
  # generate points in general position
  for i in range(numOfPoints-2):
    currentPoint = Point(random.randint(-10, 10), random.randint(-10, 10))
    
    # set the default of boolean isColinear to False
    isColinear = False 
    
    # loop through each element in the pre-existing list to check for colinearity
    for j in points_in_general:
      for k in points_in_general:
        
        # skip if j and k are the same point
        if (j == k):
          continue
          
        # three points are collinear if and only if the triangle they determine has zero area. If colinearity happens, currentPoint will not be added into the point list 
        sorted_list = sortByAngle([j, k, currentPoint])
        if isLeftTurn(sorted_list[-1],sorted_list[-2],sorted_list[0]) == 0:      
           isColinear = True
           break
      
      # generate a new point if any colinearity was found 
      if (isColinear == True):
        break
    
    #only add point that does not bring colinearity to the general position set 
    if (isColinear == False):
      points_in_general.append(currentPoint)
  
  return points_in_general

def findTriangles(triangle_list, diagonal):
  """
  triangle_list: a list of triangles generated by the triangle-splitting algorithm
  diagonal: a diagonal within the triangulated hull
  
  This function returns two lists: 
  quadrilateral_list: a list of quadrilaterals of length 4
  paired_triangle_list: a list of paired triangles (triangles that share the same edge) of length 6
  """
  #initiate the point set
  quadrilateral_list = []
  paired_triangle_list = []

  # loop through each triangle to find which two correspond to a certain diagonal
  for triangle in triangle_list:

    # return true if the triangle contains the input diagonal
    if all(point in triangle for point in diagonal):
      paired_triangle_list.append(triangle)
      
      for point in triangle:
        # avoid adding same points into the quadrilateral list
        if point not in quadrilateral_list:
          quadrilateral_list.append(point)

  return quadrilateral_list, paired_triangle_list
   

def checkSameDiagonalList(old_diagonal_list, new_diagonal_list):
  """
  This function tests if we reached Delaunay 
  """
  # set up a counter
  old_diag_len = len(old_diagonal_list)

  # return False for the first iteration since new_diagonal_list must be empty for the first iteration
  if new_diagonal_list == []:
      return False
  
  else:
      for new_diag in new_diagonal_list:
        for old_diag in old_diagonal_list:
          # check if new diagonal == old diagonal regardless of orientation of the diagoanl
          if new_diag[0] in old_diag and new_diag[1] in old_diag:
            old_diag_len -= 1 # one match found! check other new diagonals
            break
            
          else:
            continue # check other old diagonals with this new diagonal
      
      if old_diag_len == 0: # all old diagonals found a match
          return True
      
      else: # mismatch found among old diagonal list
          return False


def diagonalFlip(diagonal_list, triangle_list):
  """
  Flip the diagonal if there's an illegal edge
  """
  #initiate the newer/updated version of diagonal_list 
  new_diagonal_list = []
 
  # Stop flipping if reached Delaunay
  while checkSameDiagonalList(diagonal_list, new_diagonal_list) == False: 
      
    # make sure that diagonal_list is one version behind new_diagonal_list
    # only update diagonal_list to the newer verison when we have a non empty newer version
    if new_diagonal_list != []:
      diagonal_list = new_diagonal_list

      # build a new empty diagonal list
      new_diagonal_list = []
    
  
    
    for diagonal in diagonal_list:
      
      # find correspondence quadrilateral and the vertices
      quadrilateral_list, paired_triangle_list = findTriangles(triangle_list, diagonal)

      # make sure the points on the triangle is counter clockwise
      sortedTriangle = sortByAngle(quadrilateral_list[0:3])
      
      # define checkpoint
      checkpoint = quadrilateral_list[3]
      
      #Animation for circle
      center, radius = define_circle(sortedTriangle[0],sortedTriangle[1],sortedTriangle[2])
      circle = drawCircle(center, radius)
      time.sleep(1)
      
      #Since our points are sorted clockwise, incirclefast >= 0 indicates a valid Delaunay. When four points are cocircular, no edge flip happens.
      if incirclefast(sortedTriangle[0],sortedTriangle[1],sortedTriangle[2], checkpoint) >= 0:
        new_diagonal_list.append(diagonal)
        circle.remove()
        fig.canvas.draw()
        continue
        
      else:
        #flip the diagonal by adding the other two points in the quadrilateral
        new_diagonal = [point for point in quadrilateral_list if point not in diagonal]
        new_diagonal_list.append(new_diagonal)

        # remove the invalid diagonal in the visualization
        removeDiagonal(diagonal)

        # draw the new diagonal in the visualization
        drawDiagonal(new_diagonal,"pink")
        
        time.sleep(1)
        
        circle.remove()
        fig.canvas.draw()
        
        #update triangulation
        for triangle in paired_triangle_list:
          triangle_list.remove(triangle)
        triangle_list.append([new_diagonal[0],new_diagonal[1],diagonal[0]])
        triangle_list.append([new_diagonal[0],new_diagonal[1],diagonal[1]])
    
  return new_diagonal_list



def drawInitGraphStatic(pointSet, diagonal_list,pointsOnHull):
  """
  This function draws the triangulation generated by the triangle-splitting algorithm
  """
  # clear the previous drawing
  ax.cla()
  
  # draw initial triangulation
  for diagonal in init_diagonal_list:
      xid, yid = zip(*diagonal)
      ax.plot(xid, yid, c = "#9CBCFF", linewidth = 1, gid = diagonal)

  # draw the hull
  xh, yh = zip(*pointsOnHull)
  ax.plot(xh, yh, c = "#8BB0FE", linewidth = 1.5)

  # draw all the points
  xsc, ysc = zip(*pointSet)
  ax.scatter(xsc, ysc, c="pink", zorder = 2)

  fig.canvas.draw()
  fig.canvas.flush_events()

def removeDiagonal(gid):
  """
  Code retrieved from https://stackoverflow.com/a/40183433
  This function removes the illegal diagonal visually
  """
  for c in ax.lines:  
    # get the current group id and check if its identical to that of the invalid diagonal, if so, remove the diagonal
    if c.get_gid() == gid: 
      c.remove()
  
  fig.canvas.draw()
  fig.canvas.flush_events()
      
def drawCircle(center,radius):
  """
  This function draws a circle in correspondence to each triangle.
  Show the user visually whether or not the empty-circle property is satisfied.
  """
  # create circle object and make it show on the top layer
  circle=plt.Circle(center, radius, color='#4BD79B',fill=False, zorder = 3) 
  ax.add_patch(circle)
  fig.canvas.draw()
  fig.canvas.flush_events()
  return circle

def drawDiagonal(diagonal, color, thickness = 1):
  """
  This function draws a diagonal in the animation.
  """
  ax.autoscale(enable=False, axis='both', tight=None)
  plt.autoscale(enable=False, axis='both', tight=None)
  xd,yd = zip(*diagonal)
  ax.plot(xd,yd, c = color, linewidth = thickness,gid=diagonal)
  fig.canvas.draw()
  fig.canvas.flush_events()


# generate points in general position
test_1 = generalPosition(numOfPoints = 100)

# perform triangle splitting
pointsOnHull, sortedPointList = grahamScan(test_1)
triangle_list, diagonal_list = diagToTriang(pointsOnHull)
init_triangle_list, pointsInHull, init_diagonal_list = splitTriangle(sortedPointList, pointsOnHull, triangle_list, diagonal_list) 


# initialize the figure
fig = plt.figure()
ax = fig.add_subplot(111)

# make sure that the figure is always a square for the circle to show up normally
ax.set_aspect('equal', adjustable='box')

plt.show(block=False)
ax.autoscale(enable=False, axis='both', tight=None)

# draw init triangulation
xsc, ysc = zip(*test_1)
drawInitGraphStatic(test_1, init_diagonal_list, pointsOnHull)

time.sleep(1)

# perform Delaunay
new_diagonal_list = diagonalFlip(diagonal_list, triangle_list) 
